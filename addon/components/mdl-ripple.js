import Ember from 'ember';
import layout from '../templates/components/mdl-ripple';
import RippleMixin from '../mixins/ripple-mixin';

/* global MaterialRipple */

const CssClasses = MaterialRipple.prototype.CssClasses_;
const Constant_ = MaterialRipple.prototype.Constant_;


export default Ember.Component.extend({
  layout: layout,
  tagName: 'span',
  classNames: [CssClasses.RIPPLE],
  classNameBindings: [
      'ignoreEvents:' + CssClasses.RIPPLE_EFFECT_IGNORE_EVENTS,
      'animate:' + CssClasses.IS_ANIMATING,
      'rippleVisible:' + CssClasses.IS_VISIBLE,
      'center:' + CssClasses.RIPPLE_CENTER
  ],

  parentRippleElement: Ember.computed(function () {
    return this.nearestOfType(RippleMixin)
  }),


  init() {
    this._super(...arguments);
    this.get('parentRippleElement').registerRippleComponent(this);
    this.frameCount_ = 0;
    this.rippleSize_ = 0;
    this.x_ = 0;
    this.y_ = 0;

    // Touch start produces a compat mouse down event, which would cause a
    // second ripples. To avoid that, we use this property to ignore the first
    // mouse down after a touch start.
    this.ignoringMouseDown_ = false;

  },

  upHandler_: function(event) {
    // Don't fire for the artificial "mouseup" generated by a double-click.
    if (event && event.detail !== 2) {
      this.set('rippleVisible', false);
    }
    // Allow a repaint to occur before removing this class, so the animation
    // shows for tap events, which seem to trigger a mouseup too soon after
    // mousedown.
    window.setTimeout(function() {
      this.set('rippleVisible', false);
    }.bind(this), 0);
  },

  downHandler_: function(event) {
    var rippleElement_ = this.get('element');
    var element_ = this.get('parentRippleElement').get('element');

    if (!rippleElement_.style.width && !rippleElement_.style.height) {
      var rect = element_.getBoundingClientRect();
      this.boundHeight = rect.height;
      this.boundWidth = rect.width;
      this.rippleSize_ = Math.sqrt(rect.width * rect.width +
              rect.height * rect.height) * 2 + 2;
      rippleElement_.style.width = this.rippleSize_ + 'px';
      rippleElement_.style.height = this.rippleSize_ + 'px';
    }

    this.set('rippleVisible', true);

    if (event.type === 'mousedown' && this.ignoringMouseDown_) {
      this.ignoringMouseDown_ = false;
    } else {
      if (event.type === 'touchstart') {
        this.ignoringMouseDown_ = true;
      }
      var frameCount = this.getFrameCount();
      if (frameCount > 0) {
        return;
      }
      this.setFrameCount(1);
      var bound = event.currentTarget.getBoundingClientRect();
      var x;
      var y;
      // Check if we are handling a keyboard click.
      if (event.clientX === 0 && event.clientY === 0) {
        x = Math.round(bound.width / 2);
        y = Math.round(bound.height / 2);
      } else {
        var clientX = typeof event.clientX !== 'undefined' ? event.clientX : event.touches[0].clientX;
        var clientY = typeof event.clientY !== 'undefined' ? event.clientY : event.touches[0].clientY;
        x = Math.round(clientX - bound.left);
        y = Math.round(clientY - bound.top);
      }
      this.setRippleXY(x, y);
      this.setRippleStyles(true);
      window.requestAnimationFrame(this.animFrameHandler.bind(this));
    }
  },
  setFrameCount: function(fC) {
    this.frameCount_ = fC;
  },
  setRippleXY: function(newX, newY) {
    this.x_ = newX;
    this.y_ = newY;
  },
  getFrameCount: function() {
    return this.frameCount_;
  },
  setRippleStyles: function(start) {
    var rippleElement_ = this.get('element'),
        recentering = this.get('center');
    if (rippleElement_ !== null) {
      var transformString;
      var scale;
      var size;
      var offset = 'translate(' + this.x_ + 'px, ' + this.y_ + 'px)';
  
      if (start) {
        scale = Constant_.INITIAL_SCALE;
        size = Constant_.INITIAL_SIZE;
      } else {
        scale = Constant_.FINAL_SCALE;
        size = this.rippleSize_ + 'px';
        if (recentering) {
          offset = 'translate(' + this.boundWidth / 2 + 'px, ' +
              this.boundHeight / 2 + 'px)';
        }
      }
  
      transformString = 'translate(-50%, -50%) ' + offset + scale;
  
      rippleElement_.style.webkitTransform = transformString;
      rippleElement_.style.msTransform = transformString;
      rippleElement_.style.transform = transformString;
  
      if (start) {
        this.set('animate', false);
      } else {
        this.set('animate', true);
      }
    }
  },
  animFrameHandler: function() {
    if (this.frameCount_-- > 0) {
      window.requestAnimationFrame(this.animFrameHandler.bind(this));
    } else {
      this.setRippleStyles(false);
    }
  }

});
